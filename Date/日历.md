# 一步一步教你写一个日历插件
日历插件是个很常用的插件，尤其jq式的泛滥成灾，为了一个插件，引入一个库真是很恶心的事，这里把写日历的思路拿出来，授人以鱼不如授人以渔，大家可以沿着我的思路 做出很漂亮的UI，有好的作品可以私发给我。

## 流程
1.显示当前日期

2.显示用户输入日期


## 思路
+ 获取当前日期
+ 与用户输入日期进行换算

举例来说

1.  同年来说

	今天: 2016/11/19 星期六
	
	 2016/4/5 星期几

 计算异常简单，就是算一下差多少天，然后对7 取余，最后依据取余的结果判断是向前还是向后运算。
 
 例如这个例子
 19(11月) + 31(10月) + 30(9月) + 31(8月) + 31(7月)+ 30(6月) + 31(5月) + 30(4月) - 5(多出的5天) = 228
 
 228 % 7 = 2
 因为在今天之前所以: 星期六 - 2 = 星期四
 
 2. 跨年运算
 
 今天: 2016/11/19 星期六
  
  2015/4/20 星期几
  
  其实思路完全可以依照上面的思路，先转成同一年:
  
  2016/4/20 -  2015/4/20
  
  这里就有一个闰年的问题了，闰年的问题，也就影响2月，闰年2月29天，平年2月28天，所以不是365 就是 366. 就看有没有跨了闰年的2月
  
  闰年的计算法则
  <pre> 
  function  leapYear(year){
  	return year % 400 === 0 || (year % 100 !==0 && year % 4 === 0) 
  }
  </pre>
  
  显然2016 位闰年 也就是 366天
  
  2016/11/19 - 2016/4/20
  
  间隔213天，这里自己算，再加上 366，总共 579 天
  
  579 % 7 = 5 
  
  星期六 - 5 = 星期一
  这里简单写一下伪码
  <pre>
  function setSameYear(startYear, startMonth,startDay ,endYear, endMonth){
  for(var i=startYear;i<endYear; i++){
  var sum = 0;
if(!learYear(startYear) && learYear(startYear + 1)){
     sum += 365;
  }
  else{
  	leapYear(startYear) && startMonth > 2  && （sum +=365; continue;	）
  	leapYear(startYear) && startMonth < 2  || (startMonth == 2 && startDay < 29) && (sum += 366;continue;)
  	leapYear(endYear)  && startMonth > 2 && (sum 	+=366; continue;)
    leapYear(endYear)  && startMonth < 2  || 	(startMonth == 2 && startDay < 29) && (sum +=365; continue;)
  }
  }
  </pre> 
  
  其实就是检测两个相邻的年份差有没有跨 二月29号
  
  然后就是换算到同一年的日期差了，判断一下今年是否是闰年，然后按差的月份加咯。最后对7取余，根据在今天前后，来对取余的结果进行加减。
  
  
  好了算法就到这里了，再说一下显示的问题，我知道目的日期是星期几了，怎么显示这一月的月份。
  表格 除了 星期一 到星期天的抬头，考虑1号在星期一和星期日的情况，是31 至 37个单元格，也就是 需要6 行， 假设今天 11月 19 号，星期6，我想绘制整个月份图，怎么做呢？
  
  我们第一个思路就是回退到11月1号，因为一定在第一行，在依据星期几，往后平铺开来就好了。     
   简单算一下 同月的计算
   (19 - 1)% 7 = 4;     
   星期六 - 4 = 星期二
   
   假设抬头是星期一，那就是放在第一行第二项咯，然后铺开就好了。
   
   这就是日历的思路了，其实很简单。   	  		
